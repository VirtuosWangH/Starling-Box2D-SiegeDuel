package editor.drawingObject{		import flash.display.Sprite;	import flash.geom.Point;		import editor.utils.Calculator;	import editor.commonData.DrawingType;
		public class BaseObject extends Sprite {		public var type:String;		public var data:Object;				public var shapeData:Object;		 		public function BaseObject(type:String=""){			this.type = type;			 data = new Object();			 shapeData = new Object();			 shapeData.density = "1";		}	     	public function get objectDef():String{			var i:int;			if (type == DrawingType.BOX){				data = {x:Calculator.b2dSize(x), y:Calculator.b2dSize(y), 						width:Calculator.b2dSize(shapeData.width), height:Calculator.b2dSize(shapeData.height), 						angle: Calculator.bAngle(rotation), 						density:shapeData.density};				return  preCommandStr() + "sim.addBox({x:" + data.x + ", y:" + data.y 						+ ", width:" + data.width + ", height:" + data.height 						+ ", angle: "+ data.angle + ", density:"+ data.density+"});";			}else if (type == DrawingType.CIRCLE){				data = {x:Calculator.b2dSize(x), y:Calculator.b2dSize(y), 						radius:Calculator.b2dSize(width / 2), 						density:shapeData.density};				return  preCommandStr() + "sim.addCircle({x:" + data.x + ", y:" + data.y 						+ ", radius:" + data.radius + ", density:"+ data.density+"});";			}else if (type == DrawingType.PLOY){				var copy:Array  = [];				for (i = 0; i<shapeData.verts.length; i++){					copy[i] = shapeData.verts[i].concat();				}				data = {x:Calculator.b2dSize(x), 						y:Calculator.b2dSize(y), 						verts:format2D(Calculator.b2dSize2DArray(copy)), 						density:shapeData.density,  						angle: Calculator.bAngle(rotation)};				 return  preCommandStr() + "sim.addPoly({x:" + data.x + ", y:" + data.y + ", verts:" + data.verts + ", angle: "+ data.angle + ", density:"+ data.density+"});";			}else if (type == DrawingType.JOINT){				var bodyA:String;				var bodyB:String;				var pntA:Point = localToGlobal(shapeData.pointA)				var pntB:Point = localToGlobal(shapeData.pointB);				if (parent){					for (i = 0; i<parent.numChildren; i++){						var e:* = parent.getChildAt(i);						if (e is BaseObject){							if (e.type != "Joint"){								if (e.hitTestPoint(pntA.x, pntA.y, true)){									  bodyA = e.name +".body";									 // trace("body A : " + bodyA);								}else								if (e.hitTestPoint(pntB.x, pntB.y, true)){									  bodyB = e.name +".body";									 // trace("body B : " + bodyB);								}								//trace("check collide", e.type);							}						}					}				}				data = {a:bodyA, b:bodyB, vecA:"new b2Vec2(" + Calculator.b2dSize(pntA.x) + ", "+ Calculator.b2dSize(pntA.y)+ ")", vecB:"new b2Vec2(" + Calculator.b2dSize(pntB.x) + ", "+ Calculator.b2dSize(pntB.y)+ ")"};				return  preCommandStr() + "sim.addJoint({a:" + data.a + ", b:" + data.b + ", vecA:" + data.vecA + ", vecB:"+ data.vecB+"});";			}			return null;		}		protected function format2D(a:Array):String{			var str:String = "[";			for (var i:int = 0; i<a.length; i++){				str += "[" + a[i].toString() + "],";			}			str = str.substr(0, str.length-1);			str += "]";			return str;		}				public function preCommandStr():String{			//name = name.replace(/instance/g, "auto");			if (name.indexOf("instance") != -1){				if (parent){					for (var i:int=0; i<parent.numChildren; i++){						if (parent.getChildAt(i) == this){							name = "auto" + i;							break;						}					}				}			}			return "var " + name + ":BaseObject = ";		}		public function createFromObject(nm:String, obj:Object):void{			//This should be override by subclass		}	}}